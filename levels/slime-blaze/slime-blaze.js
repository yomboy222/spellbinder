/* slime-blaze.js */

/* code generated by command: python3 create_level.py "name=slime-blaze" "initialSpells=add-edge,remove-edge" "targetThing=treasure" "room=name:room1,things:slime rudder blaze,exits:E/room2/blaze W/room0/slime" "room=name:room2,things:brook,exits:E/room3/brook W/room1" "room=name:room3,things:hovel,exits:W/room2" "room=name:room0,things:treasure,exits:E/room1" */

levelList.push( { name:'slime-blaze', difficulty:2 } );

getLevelFunctions['slime-blaze'] = function() {

    let level = new Level('slime-blaze');
    level.folderName = 'slime-blaze';

    level.defineThingSubclasses = function() { 

        window.Blaze = class Blaze extends Thing {
            constructor(word,room,x,y) {
                super(word,room,x,y);
                this.frameDisplayTimeMS = 200;
                this.startAnimating();
            }
            passageBlockingBehavior() {
                displayMessage('Ouch, too hot!');
            }
            extraTransformIntoBehavior() {
                if (currentRoom === 'room1') {
                    passages[0].obstacle = this.getKey(); // could be "blaze" or "blazes"
                    passages[0].state = PASSAGE_STATE_BLOCKED;
                }
            }
        }

        window.Blazer = class Blazer extends Thing {
        }

        window.Blazers = class Blazers extends Thing {
        }


        window.Brook = class Brook extends Thing {
            constructor(word,room,x,y) {
                super(word,room,x,y);
                this.reblocksPassageUponReturn = true;
                this.frameDisplayTimeMS = 200;
                this.startAnimating();
            }
            extraTransformIntoBehavior() {
                if (currentRoom === 'room2') {
                    passages[0].obstacle = 'brook';
                    passages[0].state = PASSAGE_STATE_BLOCKED;
                }
            }
        }

        window.Brooks = class Brooks extends Thing {
            extraTransformIntoBehavior() {
                if (currentRoom === 'room2') {
                    passages[0].obstacle = 'brooks';
                    passages[0].state = PASSAGE_STATE_BLOCKED;
                }
            }
        }

        window.DiggingLocation = class DiggingLocation extends Thing {
            okayToDisplayWord() {
                return false;
            }
            handleDblclick(e) {
                if (level.treasureFound === true)
                    return false;

                if ('shovel' in inventory) {
                    inventory['shovel'].digUpTreasure();
                }
                else {
                    displayMessage('Could be something here, but you are not carrying anything to dig with!');
                }
            }
            getBaseY() {
                return 1; // back of z order stack
            }
        }

        window.Hovel = class Hovel extends Thing {
        }

        window.Hovels = class Hovels extends Thing {
        }

        window.Lime = class Lime extends Thing {
        }

        window.Limes = class Limes extends Thing {
        }

        window.Rook = class Rook extends Thing {
            extraTransformIntoBehavior() {
                if (!(this.getKey() in inventory))
                    this.y = 400;
            }
        }

        window.Rooks = class Rooks extends Thing {
        }

        window.Shovel = class Shovel extends Thing {
            extraTransformIntoBehavior() {
                displayMessage('Remember that to use an item, you double-click on it when it is in your inventory!');
            }

            handleDblclick(e) {
                if (currentRoom === 'room0' && ('shovel' in inventory) && !level.treasureFound) {
                    this.digUpTreasure();
                    return true;
                }
                else if ('shovel' in inventory) {
                    displayMessage("There's nothing to dig here.");
                    return true;
                }
                else {
                    return super.handleDblclick(e);
                }
            }

            digUpTreasure() {
                // change image to show dug up hole.
                let hole = thingsHere['digging_location'];
                hole.frameDisplayTimeMS = 0; // to indicate no need to cycle through frames
                hole.startAnimating();
                this.strokeNumber = 0;
                this.removeFromInventoryForUseOnScreen();
                let target = thingsHere['digging_location']; // obviously need to have checked beforehand that this is here.
                this.x =  target.x ;
                this.y = target.y - 60;
                this.startStroke();
            }

            startStroke() {
                this.strokeNumber++;
                let destX = this.x ; // - 70;
                let destY = this.y ; // + 4;
                let time = 110;
                if (this.strokeNumber % 2 == 1) {
                    destX = this.x ; // + 70;
                    destY = this.y ; // + 13;
                    time = 600;
                }
                this.setMovement(destX, destY, time);
                if (this.strokeNumber < 8) {
                    this.extraPostMovementBehavior = this.startStroke.bind(this);
                }
                else {
                    this.extraPostMovementBehavior = this.finishDiggingUpTreasure.bind(this);
                }
            }

            draw() {
                let rotation = 0;
                if (this.beginMovementTime > 0) {
                    rotation = (((Date.now() - this.beginMovementTime) / this.movementDurationMS) * Math.PI / 2 ) - 2.0; // (Math.PI/2);
                    if (this.strokeNumber % 2 == 1) {
                        rotation = -rotation - (Math.PI / 2);
                    }

                }
                // console.log(rotation);
                if (this.beginMovementTime > 0) {
                    ctx.setTransform(1, 0, 0, 1, this.x + 10, this.y + 30);
                    ctx.rotate(rotation);
                    ctx.drawImage(this.image, 0-this.halfWidth, 20-this.halfHeight, this.width, this.height);
                    ctx.rotate(0-rotation);
                    ctx.setTransform(1,0,0,1,0,0);
                }
                else
                    ctx.drawImage(this.image, this.x - this.halfWidth, this.y - this.halfHeight, this.width, this.height);
            }

            finishDiggingUpTreasure() {
                this.returnToInventoryAfterUseOnScreen();
                thingsHere['treasure'] = getThing('treasure',currentRoom,28,75);
                regenerateZOrderStack(); // otherwise won't be drawn.
                level.treasureFound = true;
            }
        }

        window.Slime = class Slime extends Thing {
            passageBlockingBehavior() {
                displayMessage('Gross!');
            }
        }

        window.Treasure = class Treasure extends Thing {
            getBaseY() {
                return 9999; // should push to top of z-order
            }
        }

        window.Treasures = class Treasures extends Thing {
        }

    }

    level.getThing = function(word,room,x,y) {
        switch (word) {
            case 'blaze' : return new Blaze(word,room,x,y);
            case 'blazer' : return new Blazer(word,room,x,y);
            case 'blazers' : return new Blazers(word,room,x,y);
            case 'blazes' : return new Blaze(word,room,x,y);
            case 'brook' : return new Brook(word,room,x,y);
            case 'brooks' : return new Brooks(word,room,x,y);
            case 'digging_location' : return new DiggingLocation(word,room,x,y);
            case 'hovel' : return new Hovel(word,room,x,y);
            case 'hovels' : return new Hovels(word,room,x,y);
            case 'lime' : return new Lime(word,room,x,y);
            case 'limes' : return new Limes(word,room,x,y);
            case 'rook' : return new Rook(word,room,x,y);
            case 'rooks' : return new Rooks(word,room,x,y);
            case 'shovel' : return new Shovel(word,room,x,y);
            case 'slime' : return new Slime(word,room,x,y);
            case 'treasure' : return new Treasure(word,room,x,y);
            case 'treasures' : return new Treasures(word,room,x,y);
            default : return undefined; // this will cause instantiation of plain-vanilla Thing.
        }
    }
    level.initialRoom = 'room1';
    level.initialX = 55; // expressed as % of way across x axis, i.e. value range is 0-100 
    level.initialY = 75;
    level.initialSpells = [ 'add-edge', 'remove-edge' ];
    level.initialInventory = {};
    level.backgroundMusicFile = 'Sneaky Snitch.mp3';
    level.allWords = [ 'blaze','blazer','blazers','blazes','brook','brooks','hovel','hovels','lime','limes','rook','rooks','rudder','rudders','shovel','slime','treasure','treasures','udder','udders' ];
    level.initialThings = [ ['digging_location','room0',40,88], ['slime','room1',18,82],['rudder','room1',40,81],['blaze','room1',81,77],['brook','room2',83,98],['hovel','room3',72,76] ];


    //['shovel','room0',60,60]


    level.targetThing = 'treasure';
    level.immovableObjects = [ 'blaze','blazes','brook','brooks','digging_location','hovel','hovels','slime' ];
    level.initialRunes = [];
    level.pluralWords = { 'blazes':'blaze', 'blazers':'blazer', 'brooks':'brook', 'hovels':'hovel', 'limes':'lime', 'rooks':'rook', 'rudders':'rudder', 'udders':'udder', 'treasures':'treasure' }
    level.additionalImageNamesToPreload = ['blaze_0', 'blaze_1', 'blaze_2'];

    level.treasureFound = false;

    level.rooms = {
        'room1': {
            boundaries: [],
            filledPolygons: [],
            passages: [ 
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'E',97, 77, 'room2', 10, 77, true, 50, 77, 'blaze', PASSAGE_STATE_BLOCKED, 73, 77),
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'W',3, 77, 'room0', 90, 77, true, 50, 77, 'slime', PASSAGE_STATE_BLOCKED, 26, 77)],
        },
        'room2': {
            boundaries: [],
            filledPolygons: [],
            passages: [ 
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'E',97, 77, 'room3', 10, 77, true, 50, 77, 'brook', PASSAGE_STATE_BLOCKED, 73, 77),
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'W',3, 77, 'room1', 90, 77, true, 50, 77)],
        },
        'room3': {
            boundaries: [],
            filledPolygons: [],
            passages: [ 
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'W',3, 77, 'room2', 90, 77, true, 50, 77)],
        },
        'room0': {
            boundaries: [],
            filledPolygons: [],
            passages: [ 
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'E',97, 77, 'room1', 10, 77, true, 50, 77)],
        },
    };
    return level;
}