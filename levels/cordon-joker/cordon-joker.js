/* cordon-joker.js */

/* code generated by command: python3 create_level.py "name=cordon-joker" "initialSpells=anagram,remove-edge,change-letter" "targetThing=rock" "room=name:room1,things:cordon,exits:E/room2/cordon" "room=name:room2,things:joker,exits:W/room1" */

/* todo: make ore give you bonus points! */

levelList.push( { name:'cordon-joker', difficulty:7 } );

getLevelFunctions['cordon-joker'] = function() {

    let level = new Level('cordon-joker');
    level.folderName = 'cordon-joker';

    level.defineThingSubclasses = function() {

        window.Cauldron = class Cauldron extends Thing {
            constructor(word, room, x, y) {
                super(word, room, x, y);
                this.numberOfBubbles = 10;
                this.bubbles = [];
                for (let i = 0; i < this.numberOfBubbles; i++) {
                    let bubble = this.getRandomBubbleData();
                    this.bubbles.push(bubble);
                }
            }

            okayToDisplayWord() {
                return false;
            }

            getRandomBubbleData() {
                let offset = 0.8 * this.width * (Math.random() - 0.5);
                let bubbleX = this.x + offset;
                let bubbleY = this.y - this.halfHeight; // (Math.sqrt( 1000 - (offset * offset)));
                let timeToPop = Date.now() + 300 + (300 * Math.random());
                let radius = 2 + (4 * Math.random());
                let delta = 1.4 + (Math.random() * 0.8);
                return {'x': bubbleX, 'y': bubbleY, 'timeToPop': timeToPop, 'radius': radius, 'delta': delta};
            }

            update() {
                super.update();
                let now = Date.now();
                for (let i = 0; i < this.numberOfBubbles; i++) {
                    this.bubbles[i].y -= this.bubbles[i].delta;
                    if (now > this.bubbles[i].timeToPop) {
                        this.bubbles[i] = this.getRandomBubbleData();
                    }
                }
            }

            draw() {
                super.draw();
                ctx.strokeStyle = 'purple';
                ctx.lineWidth = 2;
                for (let i = 0; i < this.numberOfBubbles; i++) {
                    ctx.beginPath();
                    ctx.arc(this.bubbles[i].x, this.bubbles[i].y, this.bubbles[i].radius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }

        window.Condo = class Condo extends Thing {
            constructor(word, room, x, y) {
                super(word, room, x, y);
                // this.wordDisplayOffsetY = 10;
            }

            extraTransformIntoBehavior() {
                passages[0].obstacle = 'condo';
                passages[0].state = PASSAGE_STATE_BLOCKED;
            }

            passageBlockingBehavior() {
                displayMessage("Drat, it won't open!", DEFAULT_MESSAGE_DURATION);
            }
        }

        window.Condor = class Condor extends Thing {
            extraTransformIntoBehavior() {
                passages[0].obstacle = 'condor';
                passages[0].state = PASSAGE_STATE_BLOCKED;
            }

            passageBlockingBehavior() {
                displayMessage('yikes!', DEFAULT_MESSAGE_DURATION);
                level.sounds['condor'].play();
                this.movementType = MOVEMENT_TYPE_PARABOLIC;
                this.startAnimating();
                this.setMovement(this.x,this.y,1200);
            }

            extraPostMovementBehavior() {
                this.stopAnimating();
            }
        }

        window.Cordon = class Cordon extends Thing {
            constructor(word,room,x,y) {
                super(word,room,x,y);
                this.wordDisplayOffsetY = 80;
            }
            extraTransformIntoBehavior() {
                passages[0].obstacle = 'cordon';
                passages[0].block();
            }
        }

        window.Cork = class Cork extends Thing {
        }

        window.Joke = class Joke extends Thing {
        }

        window.Ore =  class Ore extends Thing {
            handleDblclick(e) {
                if (this.alreadyBeenInCauldron)
                    return super.handleDblclick(e);

                this.soundToPlayAfterMovement = sounds['splash'];
                if (this.movable === false) {
                    return; // if it's not movable it's because it's on its way to cauldron, so ignore any further clicks.
                }
                if (this.getKey() in inventory) {
                    let cauldron = thingsHere['cauldron'];
                    if (cauldron.inRangeOfPlayer(EXTRA_SPELL_RADIUS + 20)) {
                        this.deleteAfterMovement = false;
                        this.alreadyBeenInCauldron = false;
                        this.removeFromInventoryForUseOnScreen();
                        this.movable = false; // so player can't pick up again as it moves
                        this.movementType = MOVEMENT_TYPE_PARABOLIC;
                        this.setMovement(cauldron.x, cauldron.y - cauldron.halfHeight, 1000, player.x, player.y, true);
                    }
                } else {
                    super.handleDblclick(e);
                }
            }
            extraPostMovementBehavior() {
                if (this.alreadyBeenInCauldron) {
                    this.movable = true;
                    this.returnToInventoryAfterUseOnScreen();
                }
                else {
                    this.alreadyBeenInCauldron = true;
                    displayMessage('Excellent! But please put a real "rock" in the cauldron.');
                    this.visible = false;
                    window.setTimeout(this.spitBackOut.bind(this), 1800);
                }
            }
            spitBackOut() {
                this.visible = true;
                this.movementType = MOVEMENT_TYPE_PARABOLIC;
                this.setMovement(player.x, player.y, 1000, this.x, this.y, true);
            }
        }

        window.Roc = class Roc extends Thing {
            extraTransformIntoBehavior() {
                displayMessage('Any resemblance to the condor is purely coincidental...', DEFAULT_MESSAGE_DURATION);
            }
        }

        window.Rock = class Rock extends Thing {
            handleDblclick(e) {
                this.soundToPlayAfterMovement = sounds['splash'];
                if (this.movable === false) {
                    return; // if it's not movable it's because it's on its way to cauldron, so ignore any further clicks.
                }
                if (this.getKey() in inventory) {
                    let cauldron = thingsHere['cauldron'];
                    if (cauldron.inRangeOfPlayer(EXTRA_SPELL_RADIUS + 20)) {
                        this.deleteAfterMovement = true;
                        this.removeFromInventoryForUseOnScreen();
                        this.movable = false; // so player can't pick up again as it moves
                        this.movementType = MOVEMENT_TYPE_PARABOLIC;
                        this.setMovement(cauldron.x, cauldron.y - cauldron.halfHeight, 1000, player.x, player.y, true);
                    }
                } else {
                    super.handleDblclick(e);
                }
            }

            extraPostMovementBehavior() {
                window.setTimeout(completeLevel, 2000);
            }
        }
    }

    level.getThing = function(word,room,x,y) {
        switch (word) {
            case 'cauldron' : return new Cauldron(word,room,x,y);
            case 'condo' : return new Condo(word,room,x,y);
            case 'condor' : return new Condor(word,room,x,y);
            case 'cordon' : return new Cordon(word,room,x,y);
            case 'cork' : return new Cork(word,room,x,y);
            case 'joke' : return new Joke(word,room,x,y);
            case 'ore' : return new Ore(word,room,x,y);
            case 'roc' : return new Roc(word,room,x,y);
            case 'rock' : return new Rock(word,room,x,y);
            default : return undefined; // this will cause instantiation of plain-vanilla Thing.
        }
    }
    level.initialRoom = 'room1';
    level.initialX = 40; // expressed as % of way across x axis, i.e. value range is 0-100
    level.initialY = 76;
    level.initialSpells = [ 'anagram', 'remove-edge', 'add-edge', 'change-letter' ];
    level.initialInventory = {};
    level.initialMessage = "To complete Gombrecht's potion, add a rock to the cauldron!";
    level.backgroundMusicFile = 'IMSLP111573-PMLP01846-M%C3%BAsica_Cl%C3%A1sica_-_Rondo_Alla_Turca._Wolfgang_Amadeus_Mozart.mp3'; // IMSLP76367-PMLP02397-onclassical_salvatori_debussy_suite_iv.mp3';
    level.allWords = [ 'cauldron','coke','condo','condor','cordon',
        'core','cork','donor','jock','joke','joker','ore','roc','rock','roe','rondo' ];
    level.initialThings = [ ['cauldron','room1',15,76], ['cordon','room1',65,76],['joker','room2',60,72] ];
    // level.targetThing = 'rock';
    level.immovableObjects = ['condor','condo','cordon','cauldron','donor','jock','roc'];
    level.bonusWords = ['donor', 'jock', 'ore', 'roe']
    level.initialRunes = [];
    level.sounds = { 'condor' : new Audio(getLevelPathFromFolderName(level.folderName) + '/audio/362426__tec-studio__brd-hawk.wav') };


    level.rooms = {
        'room1': {
            boundaries: [],
            filledPolygons: [],
            passages: [ 
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'E',97, 76, 'room2', 10, 76, true, 46, 76, 'cordon', PASSAGE_STATE_BLOCKED, 63, 76)],
        },
        'room2': {
            boundaries: [],
            filledPolygons: [],
            passages: [ 
               new Passage(PassageTypes.INVISIBLE_HORIZONTAL, 'W',3, 76, 'room1', 90, 76, true, 50, 76)],
        },
    };
    return level;
}